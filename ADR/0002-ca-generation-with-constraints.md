# 2. CA generation with security constraints

Date: 2025-11-09

## Status

Accepted

## Context

The Squid proxy uses SSL bumping to intercept HTTPS traffic, requiring a Certificate
Authority (CA) to sign dynamically generated certificates. The primary security risk is
CA private key compromise, which would allow an attacker to sign certificates for any
domain.

To mitigate this risk, we need to apply X.509 certificate constraints:
- **pathLenConstraint**: Limits certificate chain depth (Root CA: pathlen:1,
  Intermediate CA: pathlen:0)
- **Name Constraints**: Limits which domains the CA can issue certificates for
- **Key Usage**: Restricts certificate to CA operations only (cert sign, CRL sign)

cert-manager cannot generate CAs with the required constraints (pathLenConstraint and
Name Constraints), and we want to avoid holding the private key for the root CA inside
the cluster.

## Decision

We will use a **hybrid model** combining Vault PKI, cert-manager, and External Secrets
Operator:
- **Vault PKI (Public Key Infrastructure)** generates the Root CA with constraints
  (private key remains in Vault)
- **cert-manager with Vault Issuer** manages Intermediate CA lifecycle
- **Vault KV** stores Root CA public certificate
- **External Secrets Operator** syncs Root CA from Vault KV to Kubernetes
- **trust-manager** distributes Root CA to all namespaces

**CA Architecture:**
- **Root CA** (Vault PKI): `pathLenConstraint=1`, Name Constraints, Key Usage (cert sign, CRL sign)
- **Intermediate CA** (cert-manager): `pathLenConstraint=0`, inherits Name Constraints from Root CA
- **Leaf Certificates** (Squid): Dynamically generated by Squid using Intermediate CA

**Root CA Specifications:**
- Generated by Vault PKI with:
  - `pathLenConstraint=1` (allows one intermediate level)
  - Name Constraints (permitted: `registry.access.redhat.com`, `registry.redhat.io`,
    `*.redhat.com`, `*.access.redhat.com`, `*.connect.redhat.com`, `quay.io`,
    `.quay.io`, `cdn.quay.io`, `cdn01.quay.io`, `cdn02.quay.io`; excluded: `*`)
  - Key Usage (`keyCertSign`, `cRLSign` only)
  - Validity period: 87600h (10 years)

**Note:** `*.redhat.com`, `*.access.redhat.com`, and `*.connect.redhat.com` are required
because Squid copies DNS names from upstream certificates when generating certificates.
The `registry.access.redhat.com` certificate includes `*.redhat.com` in its Subject
Alternative Name (SAN), which must be permitted by Name Constraints. Additional hosts
will be required within the list of permitted hosts. E.g. additional cdnXX.quay.io
hosts.

**Example Vault PKI command:**

```bash
vault write pki_squid_my_cluster_root/root/generate/internal \
  common_name="Konflux Cluster Root CA" \
  organization="konflux" \
  ttl=87600h \
  key_type="rsa" \
  key_bits=2048 \
  max_path_length=1 \
  permitted_dns_domains="registry.access.redhat.com,registry.redhat.io,*.redhat.com,*.access.redhat.com,*.connect.redhat.com,quay.io,.quay.io,cdn.quay.io,cdn01.quay.io,cdn02.quay.io" \
  excluded_dns_domains="*"
```

**Example Vault policy for signing intermediate CAs for cert-manager:**

```hcl
vault policy write pki_squid_my_cluster_root-sign-intermediate - << 'POLICY'
path "pki_squid_my_cluster_root/root/sign-intermediate" {
  capabilities = ["create", "update"]
}
POLICY
```

**Intermediate CA Specifications:**
- Generated by cert-manager using Vault Issuer:
  - `pathLenConstraint=0` (cannot sign further intermediates)
  - Name Constraints: Inherited from Root CA
  - Key Usage: Certificate Sign, CRL Sign, Client Auth, Server Auth
  - Auto-renewable: cert-manager manages lifecycle
  - Validity period: TBD (renewed by cert-manager, but requires Squid restart)

**Example Vault Issuer resource:**

```yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: vault-issuer-sign-intermediate
  namespace: caching
spec:
  vault:
    path: pki_squid_my_cluster_root/root/sign-intermediate
    server: <Vault URL>
    auth:
      kubernetes:
        role: vault-issuer-role
        mountPath: /v1/auth/kubernetes-auth
        serviceAccountRef:
          name: vault-issuer
```

**Example Certificate resource:**

```yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: squid-intermediate-ca
  namespace: caching
spec:
  isCA: true
  commonName: "Squid Bumping CA"
  secretName: squid-ca-keypair
  privateKey:
    algorithm: RSA
    size: 2048
  issuerRef:
    name: vault-issuer-sign-intermediate
    kind: Issuer
  duration: 2160h
  renewBefore: 720h
  usages:
    - digital signature
    - key encipherment
    - cert sign
    - crl sign
    - client auth
    - server auth
```

**CA Distribution:**
- Root CA private key remains in Vault PKI (never exported)
- Root CA public certificate stored in Vault KV
- External Secrets Operator syncs Root CA public cert to `cert-manager` namespace
- trust-manager Bundle distributes Root CA to all namespaces
- Intermediate CA stored in `caching` namespace (managed by cert-manager)
- Squid uses Intermediate CA

**Example trust-manager Bundle manifest:**

```yaml
apiVersion: trust.cert-manager.io/v1alpha1
kind: Bundle
metadata:
  name: caching-ca-bundle
spec:
  sources:
  - secret:
      name: vault-root-ca-secret
      key: ca.crt
  target:
    configMap:
      key: ca-bundle.crt
    namespaceSelector:
      matchLabels:
        "konflux-ci.dev/type": "tenant"
```

**Example ClusterSecretStore for External Secrets Operator:**

```yaml
apiVersion: external-secrets.io/v1
kind: ClusterSecretStore
metadata:
  name: local-vault
spec:
  provider:
    vault:
      server: <Vault URL>
      path: squid_my_cluster
      version: v2
      auth:
        tokenSecretRef:
          name: vault-token
          key: token
          namespace: external-secrets-operator
```

**Example ExternalSecret for syncing Root CA from Vault KV:**

```yaml
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: vault-root-ca-secret
  namespace: cert-manager
spec:
  refreshInterval: 1h
  secretStoreRef:
    kind: ClusterSecretStore
    name: local-vault
  data:
    - secretKey: ca.crt
      remoteRef:
        key: root-ca
        property: cert
  target:
    name: vault-root-ca-secret
    creationPolicy: Owner
    deletionPolicy: Delete
```

**Dev vs Production:**
- Dev: Vault and External Secrets Operator installed inside the dev cluster for testing
- Production/Staging: Vault and External Secrets Operator present in the cluster

## Consequences

Positive:
- **Root CA private key security**: Private key remains in Vault PKI, never exported to
  Kubernetes
- **Automated Intermediate CA lifecycle**: cert-manager manages Intermediate CA
  creation, renewal, and rotation
- **Two-tier security model**: Root CA (pathlen:1) → Intermediate CA (pathlen:0) → Leaf
  certificates
- **Name Constraints enforcement**: Applied at Root CA level, inherited by Intermediate
  CA
- **Centralized management**: Root CA managed in Vault, Intermediate CA managed by
  cert-manager
- **Automatic distribution**: External Secrets Operator and trust-manager handle Root
  CA sync and distribution
- **Audit trail**: Vault audit logs for Root CA operations, cert-manager logs for
  Intermediate CA operations

Negative:
- **Operational complexity**: Requires coordination between Vault PKI, cert-manager,
  External Secrets Operator, and trust-manager
- **Root CA rotation (if key is compromised)**: Requires manual steps (generate new Root
  CA, set as default, update Vault KV, wait for sync)
- **Intermediate CA recovery**: Requires Certificate resource recreation after deletion
  (recreation can be handled by Helm)
- **Multiple components**: More moving parts than a single-tool approach
- **Dependency management**: All components must be properly configured and synchronized

## Required Kubernetes RBAC and Vault Configuration

For cert-manager to authenticate with Vault and sign Intermediate CAs, the following Kubernetes resources and Vault configuration are required:

**Example ServiceAccount, Role, and RoleBinding:**

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-issuer
  namespace: caching
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: vault-issuer
  namespace: caching
rules:
  - apiGroups: ['']
    resources: ['serviceaccounts/token']
    resourceNames: ['vault-issuer']
    verbs: ['create']
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vault-issuer
  namespace: caching
subjects:
  - kind: ServiceAccount
    name: cert-manager
    namespace: cert-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: vault-issuer
```

**Example ClusterRole and ClusterRoleBinding for Vault token validation:**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vault-token-reviewer
rules:
  - apiGroups: ['authentication.k8s.io']
    resources: ['tokenreviews']
    verbs: ['create']
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-token-reviewer
subjects:
  - kind: ServiceAccount
    name: vault
    namespace: vault
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vault-token-reviewer
```

**Example Vault Kubernetes auth role configuration:**

```bash
vault write auth/kubernetes-auth/role/vault-issuer-role \
  bound_service_account_names=vault-issuer \
  bound_service_account_namespaces=caching \
  policies=pki_squid_my_cluster_root-sign-intermediate \
  ttl=1h
```

## Intermediate CA Compromise Recovery

In the event that the Intermediate CA private key is compromised, a controlled root
rotation process is used to invalidate the compromised Intermediate CA and restore
service. This process consists of two phases:

### Phase 1: Invalidate the Compromised Intermediate CA

This phase rotates the Root CA, which immediately makes the compromised Intermediate CA
(and any certificates it signed) untrusted by the entire cluster.

1. **Generate New Root CA**: Use Vault PKI to create a new Root CA with the same
   constraints:
   ```bash
   vault write pki_squid_my_cluster_root/root/rotate/internal \
     common_name="Konflux Cluster Root CA" \
     organization="konflux" \
     max_path_length=1 \
     ttl=87600h \
     key_bits=2048 \
     key_type=rsa \
     permitted_dns_domains="registry.access.redhat.com,registry.redhat.io,*.redhat.com,*.access.redhat.com,*.connect.redhat.com,quay.io,.quay.io,cdn.quay.io,cdn01.quay.io,cdn02.quay.io" \
     excluded_dns_domains="*"
   ```

2. **Activate New Root CA**: Set the newly generated Root CA as the default issuer:
   ```bash
   vault write pki_squid_my_cluster_root/config/issuers default="<NEW_ISSUER_ID>"
   ```

3. **Store New Root CA in Vault KV**: Update Vault KV with the new Root CA public
   certificate for External Secrets Operator to sync:
   ```bash
   vault kv put squid_my_cluster/root-ca cert="$(vault read -field=certificate pki_squid_my_cluster_root/cert/ca)"
   ```

4. **Distribute New Trust**: External Secrets Operator automatically syncs the new Root
   CA public certificate to Kubernetes, and trust-manager distributes it to all
   namespaces via the Bundle.

5. **(Optional) Clean Up**: Delete the old, compromised Root CA issuers from Vault.

At this point, the compromised Intermediate CA is invalid, as it was signed by the
old Root CA, which is no longer trusted. All pipelines will fail, which is the correct
and desired security state.

### Phase 2: Recover Squid Service

This phase issues a new, valid Intermediate CA so Squid can resume its work.

1. **Delete Intermediate CA Certificate Resource**: Delete the compromised Certificate
   resource from Kubernetes to force cert-manager to request a new one:
   ```bash
   kubectl delete certificate squid-intermediate-ca -n caching
   ```

2. **Recreate Certificate Resource**: Recreate the Certificate resource (can be handled
   by Helm). cert-manager will automatically request a new Intermediate CA from Vault.

3. **Issue New Intermediate CA**: cert-manager (using the Vault Issuer) contacts Vault.
   Since the default Root CA has been changed, Vault signs the new Intermediate CA with
   the new Root CA. cert-manager automatically updates the `squid-ca-keypair` secret
   with the new Intermediate CA.

4. **Restart Squid**: Restart the Squid deployment to load the new, valid Intermediate
   CA:
   ```bash
   kubectl rollout restart deployment squid -n caching
   ```

Service is now restored. The new Intermediate CA is trusted by all pods because both are
part of the new, clean trust chain. The compromised Intermediate CA remains invalid and
cannot be used.
